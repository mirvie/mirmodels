% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/glm.R
\name{train_glm}
\alias{train_glm}
\title{Train a Generalized Lasso linear model.}
\usage{
train_glm(
  training_data,
  outcome,
  metric = "mn_log_loss",
  na_action = c("medianimpute", "knnimpute"),
  lambda = NULL,
  cv_nfolds = 10,
  id_col = NULL,
  strata = NULL,
  selection_method = "Breiman",
  include_nullmod = TRUE,
  err_if_nullmod = FALSE,
  warn_if_nullmod = TRUE,
  n_cores = 1
)
}
\arguments{
\item{training_data}{A data frame. The data used to train the model.}

\item{outcome}{A string. The name of the outcome variable. This must be a
column in \code{training_data}.}

\item{metric}{A string. The probability metric to choose the best model.
and select the best one. Common choices are \code{"mn_log_loss"}, \code{"roc_auc"}
and \code{"accuracy"}. This should be a metric that is available in the
\code{yardstick} package, but use e.g. "mae" and not "yardstick::mae" in this
argument.
If you specify this as a multi-element character vector, the first element will be used to select the best model; subsequent metrics will also be reported for that model in the \code{cv_performance} attribute of the the returned object.)`}

\item{na_action}{A string. How to impute missing data in explanatory
variables\code{"medianimpute"} or \code{"knnimpute"}. See
\code{\link[recipes:step_impute_median]{recipes::step_medianimpute()}} and \code{\link[recipes:step_impute_knn]{recipes::step_knnimpute()}}. Default is
\code{"medianimpute"}.}

\item{lambda}{A numeric vector. Optional. A grid of lambdas for tuning the
Lasso. If you leave this as \code{NULL}, recommended, a sensible grid is chosen
for you.}

\item{cv_nfolds}{A positive integer. The number of folds for
cross-validation.}

\item{id_col}{A string. If there is a sample identifier column, specify it
here to tell the model not to use it as a predictor.}

\item{strata}{A string. Variable to stratify on when splitting for
cross-validation.}

\item{selection_method}{A string. How to select the best model. There are two
options: "Breiman" and "absolute". "absolute" selects the best model by
selecting the model with the best mean performance according to the chosen
metric. "Breiman" selects the simplest model that comes within one standard
deviation of the best score. The idea being that simple models generalize
better, so it's better to select a simple model that had near-best
performance.}

\item{include_nullmod}{A bool. Include the null model (predicts mean or most
common class every time) in the model comparison? This is recommended. If
the null model comes within a standard deviation of the otherwise best
model, the null model is chosen instead.}

\item{err_if_nullmod}{A bool. If the null model is chosen, throw an error
rather than returning the null model.}

\item{warn_if_nullmod}{A bool. Warn if returning the null model?}

\item{n_cores}{A positive integer. The cross-validation can optionally be
done in parallel. Specify the number of cores for parallel processing here.}
}
\value{
A \link[parsnip:model_fit]{parsnip::model_fit} object. To use this fitted model \code{mod} to make
predictions on some new data \code{df_new}, use
\code{predict(mod, new_data = df_new)}.
}
\description{
Train a generalized Lasso linear model. The training routine automatically
selects the best lambda parameter using \code{\link[glmnet:cv.glmnet]{glmnet::cv.glmnet()}}.
}
\details{
The final model will be evaluated with the metric of your choice, but the
hyperparameter tuning will be done using deviance. This is necessary to use
\code{\link[glmnet:cv.glmnet]{glmnet::cv.glmnet()}}.
}
\examples{
iris_data <- janitor::clean_names(datasets::iris)
iris_data_split <- rsample::initial_split(iris_data, strata = species)
mod <- train_glm(
  training_data = rsample::training(iris_data_split),
  outcome = "species",
  metric = c("mn_log_loss", "roc_auc"),
  n_cores = 5
)
preds <- predict(mod, new_data = rsample::testing(iris_data_split)) \%>\%
  magrittr::set_names("pred") \%>\%
  dplyr::mutate(truth = rsample::testing(iris_data_split)$species)
yardstick::accuracy(preds, truth, pred)
preds_prob <- predict(mod,
  new_data = rsample::testing(iris_data_split),
  type = "prob"
)
dplyr::bind_cols(preds_prob,
  truth = rsample::testing(iris_data_split)$species
)
yardstick::mn_log_loss_vec(
  truth = rsample::testing(iris_data_split)$species,
  estimate = as.matrix(preds_prob)
)
}
\seealso{
Other model trainers: 
\code{\link{train_gbm}()},
\code{\link{train_lm}()}
}
\concept{model trainers}
