% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gbm.R
\name{train_gbm}
\alias{train_gbm}
\title{Train a gradient boosted model.}
\usage{
train_gbm(
  training_data,
  outcome,
  metric,
  hyper_param_grid = list(trees = c(5, 10, 20, 40), tree_depth = c(1, 2), learn_rate =
    c(0.01, 0.1, 0.2, 0.5)),
  cv_nfolds = 5,
  cv_nreps = 1,
  id_col = NULL,
  strata = NULL,
  selection_method = "Breiman",
  simplicity_params = NULL,
  include_nullmod = TRUE,
  err_if_nullmod = FALSE,
  warn_if_nullmod = TRUE,
  n_cores = 1
)
}
\arguments{
\item{training_data}{A data frame. The data used to train the model.}

\item{outcome}{A string. The name of the outcome variable. This must be a
column in \code{training_data}.}

\item{metric}{A string. The probability metric to choose the best model.
and select the best one. Common choices are \code{"mn_log_loss"}, \code{"roc_auc"}
and \code{"accuracy"}. This should be a metric that is available in the
\code{yardstick} package, but use e.g. "mae" and not "yardstick::mae" in this
argument.
If you specify this as a multi-element character vector, the first element will be used to select the best model; subsequent metrics will also be reported for that model in the \code{cv_performance} attribute of the the returned object.)`}

\item{hyper_param_grid}{A data frame with one row per hyperparameter
combination. The column names give the hyper parameter names. Can
optionally be passed as a list which is made into a tibble by
\code{\link[tidyr:expand_grid]{tidyr::expand_grid()}}.}

\item{cv_nfolds}{A positive integer. The number of folds for
cross-validation.}

\item{cv_nreps}{A positive integer. The number of repeated rounds in the
cross-validation.}

\item{id_col}{A string. If there is a sample identifier column, specify it
here to tell the model not to use it as a predictor.}

\item{strata}{A string. Variable to stratify on when splitting for
cross-validation.}

\item{selection_method}{A string. How to select the best model. There are two
options: "Breiman" and "absolute". "absolute" selects the best model by
selecting the model with the best mean performance according to the chosen
metric. "Breiman" selects the simplest model that comes within one standard
deviation of the best score. The idea being that simple models generalize
better, so it's better to select a simple model that had near-best
performance.}

\item{simplicity_params}{A character vector. For \code{selection_method = "Breiman"}. These are passed directly to \code{\link[tune:show_best]{tune::select_by_one_std_err()}}
and used to sort \code{hyper_param_grid} by simplicity. To sort descending, put
a minus in front of the parameter. For example, to sort ascending on "x"
and then descending on "y", use \code{simplicity_params = c("x", "-y")}. See
\code{\link[tune:show_best]{tune::select_by_one_std_err()}} for details.}

\item{include_nullmod}{A bool. Include the null model (predicts mean or most
common class every time) in the model comparison? This is recommended. If
the null model comes within a standard deviation of the otherwise best
model, the null model is chosen instead.}

\item{err_if_nullmod}{A bool. If the null model is chosen, throw an error
rather than returning the null model.}

\item{warn_if_nullmod}{A bool. Warn if returning the null model?}

\item{n_cores}{A positive integer. The cross-validation can optionally be
done in parallel. Specify the number of cores for parallel processing here.}
}
\value{
A \link[parsnip:model_fit]{parsnip::model_fit} object. To use this fitted model \code{mod} to make
predictions on some new data \code{df_new}, use
\code{predict(mod, new_data = df_new)}.
}
\description{
Train a gradient boosted model,
selecting hyperparameters \code{trees}, \code{tree_depth} and \code{learn_rate} by cross-validation.
}
\examples{
iris_data <- janitor::clean_names(datasets::iris)
iris_data_split <- rsample::initial_split(iris_data, strata = species)
iris_training_data <- rsample::training(iris_data_split)
iris_testing_data <- rsample::testing(iris_data_split)
mod <- train_gbm(
  training_data = iris_training_data, outcome = "species",
  metric = "mn_log_loss",
  hyper_param_grid = list(
    trees = c(20, 50),
    tree_depth = c(1, 2),
    learn_rate = c(0.01, 0.1)
  ),
  simplicity_params = c("trees", "learn_rate"),
  strata = c("species"),
  n_cores = 5
)
preds <- predict(mod, new_data = iris_testing_data, type = "prob")
dplyr::bind_cols(preds, truth = iris_testing_data$species)
yardstick::mn_log_loss_vec(
  truth = iris_testing_data$species,
  estimate = as.matrix(preds)
)
}
\seealso{
Other model trainers: 
\code{\link{train_glm}()},
\code{\link{train_lm}()}
}
\concept{model trainers}
